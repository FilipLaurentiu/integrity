use cairo_verifier::{
    table_commitment::table_commitment::{TableCommitment, TableDecommitment, TableCommitmentWitness, TableCommitmentConfig},
    vector_commitment::vector_commitment::VectorCommitmentConfigImpl,
    common::asserts::assert_in_range,
    air::layouts::recursive::{ // TODO: TEMPORARY, make generic
        traces::{MAX_N_COLUMNS},
        constants::{NUM_COLUMNS_FIRST, NUM_COLUMNS_SECOND},
    },
};

// A protocol component (see stark.cairo for details about protocol components) for the traces
// of the CPU AIR.
// This component is commonly right before the FRI component.
// In this case:
//   n_queries = n_fri_queries * 2^first_fri_step.
//   decommitment.original.n_queries = n_original_columns * n_queries.
//   decommitment.interaction.n_queries = n_interaction_columns * n_queries.

// Commitment values for the Traces component. Used to generate a commitment by "reading" these
// values from the channel.
#[derive(Drop, Copy, Serde)]
struct TracesUnsentCommitment {
    original: felt252,
    interaction: felt252,
}

// Commitment for the Traces component.
#[derive(Drop, PartialEq, Serde)]
struct TracesCommitment<InteractionElements> {
    // Commitment to the first trace.
    original: TableCommitment,
    // The interaction elements that were sent to the prover after the first trace commitment (e.g.
    // memory interaction).
    interaction_elements: InteractionElements,
    // Commitment to the second (interaction) trace.
    interaction: TableCommitment,
}

// Responses for queries to the AIR commitment.
// The queries are usually generated by the next component down the line (e.g. FRI).
#[derive(Drop, Copy, Serde)]
struct TracesDecommitment {
    // Responses for queries to the original trace.
    original: TableDecommitment,
    // Responses for queries to the interaction trace.
    interaction: TableDecommitment,
}

// A witness for a decommitment of the AIR traces over queries.
#[derive(Drop, Copy, Serde)]
struct TracesWitness {
    original: TableCommitmentWitness,
    interaction: TableCommitmentWitness,
}

// Configuration for the Traces component.
#[derive(Drop, Copy, Serde)]
struct TracesConfig {
    original: TableCommitmentConfig,
    interaction: TableCommitmentConfig,
}

#[generate_trait]
impl TracesConfigImpl of TracesConfigTrait {
    fn validate(
        self: @TracesConfig,
        log_eval_domain_size: felt252,
        n_verifier_friendly_commitment_layers: felt252,
    ) {
        assert_in_range(*self.original.n_columns, 1, MAX_N_COLUMNS + 1);
        assert_in_range(*self.interaction.n_columns, 1, MAX_N_COLUMNS + 1);
        assert(*self.original.n_columns == NUM_COLUMNS_FIRST.into(), 'Wrong number of columns');
        assert(*self.interaction.n_columns == NUM_COLUMNS_SECOND.into(), 'Wrong number of columns');

        self.original.vector.validate(log_eval_domain_size, n_verifier_friendly_commitment_layers);

        self
            .interaction
            .vector
            .validate(log_eval_domain_size, n_verifier_friendly_commitment_layers);
    }
}

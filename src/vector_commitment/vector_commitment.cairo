use cairo_verifier::common::flip_endianness::FlipEndiannessTrait;
use cairo_verifier::common::{array_append::ArrayAppendTrait, blake2s::blake2s, math::pow};
use poseidon::hades_permutation;
// TODO: remove
use core::debug::PrintTrait;

// Commitment for a vector of field elements.
#[derive(Drop, Copy)]
struct VectorCommitment {
    config: VectorCommitmentConfig,
    commitment_hash: felt252
}

#[derive(Drop, Copy)]
struct VectorCommitmentConfig {
    height: felt252,
    n_verifier_friendly_commitment_layers: felt252,
}

// A query to the vector commitment.
#[derive(Drop, Copy)]
struct VectorQuery {
    index: felt252,
    value: felt252,
}

// A query to the vector commitment that contains also the depth of the query in the Merkle tree.
#[derive(Drop, Copy)]
struct VectorQueryWithDepth {
    index: felt252,
    value: felt252,
    depth: felt252,
}

// Witness for a decommitment over queries.
#[derive(Drop, Copy)]
struct VectorCommitmentWitness {
    // The authentication values: all the siblings of the subtree generated by the queried indices,
    // bottom layer up, left to right.
    authentications: Span<felt252>,
}

fn validate_vector_commitment(
    config: VectorCommitmentConfig,
    expected_height: felt252,
    n_verifier_friendly_commitment_layers: felt252,
) {
    assert(false, 'not implemented');
}

fn vector_commitment_decommit(
    commitment: VectorCommitment,
    n_queries: felt252,
    queries: Array<VectorQuery>,
    witness: VectorCommitmentWitness,
) {
    let shift = pow(2, commitment.config.height);
    let shifted_queries = shift_queries(queries.span(), shift, commitment.config.height).span();

    let mut i: u32 = 0;
    loop {
        if i == shifted_queries.len() {
            break;
        }
        let q: VectorQueryWithDepth = *shifted_queries.at(i);
        q.index.print();
        q.value.print();
        q.depth.print();
        i += 1;
    };
}

fn shift_queries(queries: Span<VectorQuery>, shift: felt252, height: felt252) -> Array<VectorQueryWithDepth> {
    let mut shifted_queries = ArrayTrait::new();
    let mut i = 0;
    loop {
        if i == queries.len() {
            break;
        };
        let q = *queries[i];
        shifted_queries.append(VectorQueryWithDepth {
            index: q.index + shift,
            value: q.value,
            depth: height,
        });
        i += 1;
    };
    shifted_queries
}

fn hash_blake_or_poseidon(x: felt252, y: felt252, is_verifier_friendly: bool) -> felt252 {
    if is_verifier_friendly {
        let (hash, _, _) = hades_permutation(x, y, 2);
        hash
    } else {
        truncated_blake2s(x, y)
    }
}

fn truncated_blake2s(x: felt252, y: felt252) -> felt252 {
    let mut data = ArrayTrait::<u32>::new();
    data.append_big_endian(x);
    data.append_big_endian(y);
    let hash = blake2s(data).flip_endianness() % 0x10000000000000000000000000000000000000000;
    hash.try_into().unwrap()
}

use cairo_verifier::common::flip_endianness::FlipEndiannessTrait;
use cairo_verifier::common::{array_append::ArrayAppendTrait, blake2s::blake2s,};
use poseidon::hades_permutation;


// Commitment for a vector of field elements.
#[derive(Drop, Copy)]
struct VectorCommitment {
    config: VectorCommitmentConfig,
    commitment_hash: felt252
}

#[derive(Drop, Copy)]
struct VectorCommitmentConfig {
    height: felt252,
    n_verifier_friendly_commitment_layers: felt252,
}

// A query to the vector commitment.
#[derive(Drop, Copy)]
struct VectorQuery {
    index: felt252,
    value: felt252,
}

// Witness for a decommitment over queries.
#[derive(Drop, Copy)]
struct VectorCommitmentWitness {
    // The authentication values: all the siblings of the subtree generated by the queried indices,
    // bottom layer up, left to right.
    authentications: Span<felt252>,
}

fn validate_vector_commitment(
    config: VectorCommitmentConfig,
    expected_height: felt252,
    n_verifier_friendly_commitment_layers: felt252,
) {
    assert(false, 'not implemented');
}

fn vector_commitment_decommit(
    commitment: VectorCommitment,
    n_queries: felt252,
    queries: Array<VectorQuery>,
    witness: VectorCommitmentWitness,
) {
    assert(false, 'not implemented');
}

fn hash_blake_or_poseidon(x: felt252, y: felt252, is_verifier_friendly: bool) -> felt252 {
    if is_verifier_friendly {
        let (hash, _, _) = hades_permutation(x, y, 2);
        hash
    } else {
        truncated_blake2s(x, y)
    }
}

fn truncated_blake2s(x: felt252, y: felt252) -> felt252 {
    let mut data = ArrayTrait::<u32>::new();
    data.append_big_endian(x);
    data.append_big_endian(y);
    let hash = blake2s(data).flip_endianness() % 0x10000000000000000000000000000000000000000;
    hash.try_into().unwrap()
}
